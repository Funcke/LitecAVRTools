/*
    exampleTimer16Bit_PWM - Test-Module for Timer_16Bit.h and
    Timer_16Bit.cpp for Timer-mode 8 (phase-and-frequency-correct mode with
    ICRn-Register as TOP-value)

    This is part of the LitecAVRTools library.

    Copyright (c) 2018 Wolfgang Zukrigl

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/*
    Two hardware-PWM-signals are created with Timer/Counter 1 in phase-and-
    frequency-correct mode, where the ICR1-Register is used as top-value.
    The two PWM-Signals appear on the OC1A and the OC1B-pins (On the
    ATmega328p these are the pins PB1 and PB2).
    The two pins drive two transistors of a half-bridge. The "upper" transistor
    is driven by pin OC1B. It is turned on with a low-voltage-level on
    pin OC1B, so you can use a pnp-bipolar-transistor or a p-channel-MOSFET.
    The "lower" transistor is driven by pin OC1A. A high-voltage-level on
    pin OC1A turns the transistor on, so an npn-biplolar-transistor or an
    n-channel-MOSFET can be used.
    Connect an 8-Ohm-speaker in series with a 220 Micro-Farad electrolytic
    capacitor between the output of the half-bridge and GND.

    The two PWM-pins are first initialized to put out a voltage-level that
    turn off both transistors of the half-bridge. This is done by a "force-
    compare-match" in normal mode.

    Then a 40 kHz PWM-signal is generated by the Timer (supposed a
    main-oscillator-frequency of 16MHz). The two compare-match-values (OCR1A
    and OCR1B-values) always differ by a constant, small amount. This ensures,
    that after turning off one transistor, the other transistor is turned on
    after a short dead-time. (If both transistors are turned on at the same
    time, this results in a short-circuit connecting VCC and GND via the two
    transistors. This must never occur!)

    The duty-cycle of the PWM-signals are changed every 5th PWM-period (this
    means that they are updated 8000 times a second). The contents of a
    wav-file saying the word "hello" are put out.
*/

#include <stdint.h>

#include <avr/interrupt.h>
#include <avr/pgmspace.h>

#include "GpioPinMacros.h"
#include "Timer16Bit.h"

#include "soundfile.h"


GpioPinObject upperTransistorOc1b  = makeGpioPinObject( GpioPin( B, 2 ) );
GpioPinObject lowerTransistorOc1a  = makeGpioPinObject( GpioPin( B, 1 ) );
TimerCounter16Bit tc1 = makeTimerCounter16BitObject( 1 );

int main()
{
    //First initialize the PWM-Pins in normal mode, with Timer-clock off,
    //using "force compare match"
    tc1.setMode( T16_NORMAL );
    tc1.selectClockSource( T16_CLK_OFF );

    //Put out high-voltage-level on pin OC1B (turn upper Transistor off)
    //and low-voltage-level on pin OC1A (turn lower transistor off)
    tc1.setPwmPinMode( T16_COMP_B, T16_PIN_SET_ON_MATCH );
    tc1.setPwmPinMode( T16_COMP_A, T16_PIN_CLEAR_ON_MATCH );
    tc1.forceOutputCompareMatch(T16_COMP_B | T16_COMP_A);
    //The "data-direction" (input/output) is still controlled by the DDR-Register, so finally make the pins outputs
    upperTransistorOc1b.setModeOutput();
    lowerTransistorOc1a.setModeOutput();
    //usart0.usartPrintf("TCCR1A = 0x%2x, TCCR1B=0x%2x\r\n",TCCR1A, TCCR1B);

    //Not start PWM-mode
    tc1.setMode( T16_PWM_PHI_F_CORRECT_ICRN );
    tc1.setTopValue( 200 ); //results with prescaler 1 and main-cpu-frequency of 16MHz in 40kHz-PWM-period
    tc1.setPwmPinMode(T16_COMP_B, T16_PIN_PWM_INVERTED);
    tc1.setPwmPinMode(T16_COMP_A, T16_PIN_PWM_INVERTED);
    //The difference between the two compare-match-values is maintained constant all the time. This
    //difference determines the dead-time (time between turning off one transistor, and turning on the other transistor)
    tc1.setCompareMatchValue(T16_COMP_B, 80);
    tc1.setCompareMatchValue(T16_COMP_A, 120);

    //Overflow-Interrupts occur in phase-and-freqency-correct mode, when the
    //count-register has counted up and down again, and has reached 0.
    tc1.enableInterrupts(T16_INT_OVERFLOW);

    tc1.selectClockSource(T16_PRESC_1); //finally start the timer

    sei(); //globally enable interrupts

    while(1)
    { /*empty*/ }

}



//
ISR(TIMER1_OVF_vect)
{
    static uint8_t cyclesCounter = 0; //counts from 0 to 4, each 5 PWM-periods
    static uint16_t ticks = 0;
    static uint16_t index = 0;

    //Only execute code every 5th call of this ISR
    cyclesCounter++;
    if (cyclesCounter < 5)
        return;

    cyclesCounter=0;

    ticks++; //incremented every 5th call of this ISR (that is 8000 times per second)

    //Don't do anything for the first 8000 ticks (for the first second)
    if (ticks < 8000)
        return;


    //get next value from soundData

    uint8_t sample = pgm_read_byte(&soundData[index]);
    index++;
    //reached end? If yes, start again
    if (sample==0xFF)
    {
        ticks=0;
        index=0;
        sample=100; //mean value
    }

   // uint8_t sample = (ticks%20>10)?140:60;
    tc1.setCompareMatchValue(T16_COMP_B, sample-20);
    tc1.setCompareMatchValue(T16_COMP_A, sample+20);

}

